# 객체 지향 프로그래밍 (Object Oriented Programming)


## 📌 절차적 프로그래밍 vs 객체 지향 프로그래밍

절차적 프로그래밍과 객체 지향 프로그래밍은 반대되는 개념이 아니다. 초기 객체 지향 프로그래밍이라는 패러다임이 등장하기 전, 대부분의 언어들이 절차적 프로그래밍을 사용하였다. 하지만 소프트웨어가 급격히 발전하면서 절차적 프로그래밍은 한계에 부딪혔다. 큰 규모의 복잡한 프로젝트를 하기엔 가독성도 떨어지고 유지보수가 힘들어진 것이다. 

이를 보완하기위해 등장한 것이 **객체 지향 프로그래밍(Object Oriented Programming**) 이다. 객체 지향 프로그래밍은 데이터와 기능을 별개로 취급하지 않고, ‘객체’로 한 번에 묶어서 처리할 수 있게 만들었다. 이로인해 가독성과 유지보수성이 향상되었다.

👉 자바스크립트는 엄밀히 말해 객체 지향 언어는 아니나, 객체 지향 패턴으로 작성할 수 있다. (추가공부 필요 ❓)

![코드스테이츠 강의 자료ppt 중 발췌](https://user-images.githubusercontent.com/89282099/173228937-4d6a7efb-2f5e-4651-9698-5cd40a184464.png)
코드스테이츠 강의 자료ppt 중 발췌


### 🧩 객체지향, 왜 좋을까?
|  | 절차지향 | 객체지향 |
| --- | --- | --- |
| 특성 | 컴퓨터의 처리구조와 유사 | 사람의 사고방식에 가까움 |
| 메모리 사용 | 적음 | 많음 |
| 처리 속도 | 빠름 | 느림 |
| 재활용성 | 낮음 | 높음 |
| 코드 이해 | 어려움 | 쉬움 |
| 디버깅(유지보수) | 어려움 | 쉬움 |
| 대형 프로젝트 | 어려움 | 상대적으로 쉬움 |

<br/>

> 💡 **객체지향이 무조건 좋은건 아니다! 하나의 프로그래밍 방법론일 뿐.**
>
>    👉 각 방법론의 **장단점** 을 잘 알고, 상황에 맞는 방법론을 선택하면 된다.
> - 메모리 관리가 중요하다면? → 메모리 적게 쓰는 **절차지향**
> - 사람들과의 협업이 필요하다면? → 코드 이해가 쉬운 **객체지향**

<br/>

## 📌 OOP : 객체 지향 프로그래밍 (Object Oriented Programming)

: **상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법**

객체 지향 프로그래밍은 프로그램 설계 철학 중 하나이다. 

객체 지향 프로그래밍(OOP, Object-oriented programming)은 사람이 세계를 보고 이해하는 방법과 매우 흡사하다. 즉 우리가 세상을 대상(object)과 대상(object)의 상호작용으로 이해하듯이 프로그래밍 코드도 객체와 객체의 상호작용으로 구현한 것이다.

OOP는 프로그램에 필요한 모든 것을 ‘객체'로 그룹화하고, 이 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 이 때 객체는  속성(attribute)과 메서드(method)의 묶음이며, 앞서 배웠듯이 클래스를 통해 생성할 수 있다.

<br/>

## 📌 객체 지향 프로그래밍의 주요 개념(장점) 4가지

1. 캡슐화 (Encapsulation)   →  코드 복잡성 ⬇️ + 재사용성 ⬆️
2. 추상화 (Abstraction)   →  코드 복잡성 ⬇️ + 단순화된 사용으로 변화에 대한 영향 최소화
3. 상속 (Inheritance)   →  중복 코드 제거(= 재사용성 ⬆️)
4. 다형성 (Polymorphism)   → 동일한 메서드에 대해 if/else 같은 조건문 대신 객체의 특성에 맞게 달리 작성하는 것 가능

### 🧩 1. 캡슐화 Encapsulation

캡슐화는 데이터와 기능을 하나의 단위로 묶는 것이다.

- **은닉(hiding)**
    
    : 구현은 숨기고, 동작은 노출시킴
    
    - 캡슐화라는 개념은 "은닉화"의 특징도 포함한다.
    - **은닉화는 내부 데이터나 내부 구현이 외부로 노출되지 않도록 만드는 것.**
    - 디테일한 구현이나 데이터는 숨기고, 객체 외부에서 필요한 동작(메서드)만 노출
    - 은닉화의 특징을 살려서 코드를 작성하면 객체 내 메서드의 구현만 수정하고, 노출된 메서드를 사용하는 코드 흐름은 바뀌지 않도록 만들 수 있다.
    - 더 엄격한 클래스는 속성의 직접적인 접근을 막고, 설정하는 함수(setter), 불러오는 함수(getter)를 철저하게 나누기도 한다.
- **느슨한 결합(Loose Coupling)**
    
    : 언제든 구현을 수정할 수 있음
    
    - 캡슐화는 외부에서 앞서 말했던 데이터(속성)와 기능(메서드)을 따로 정의하는 것이 아닌, 하나의 객체 안에 넣어서 묶는 것이다. 데이터(속성)와 기능(메서드)들이 느슨하게 결합되는 것!
    - 느슨한 결합 = 코드 실행 순서에 따라 절차적으로 코드를 작성하는 것이 아니라, **코드가 상징하는 실제 모습과 닮게 코드를 모아 결합하는 것!**
    - 예를 들어 마우스의 경우, 마우스의 상태를 속성(property)으로 정하고 클릭, 이동을 메서드(method)로 정해서 코드만 보고도 인스턴스 객체의 기능을 상상할 수 있게 작성하는 것이 느슨한 결합을 추구하는 코드 작성법이다.

### 🧩 2. 추상화 Abstraction

추상화는 내부 구현은 아주 복잡한데, 실제로 노출되는 부분은 단순하게 만든다는 개념이다.

- 예를 들어 전화라는 객체가 있다면, 그 안에는 스피커와 마이크가 존재하고, 서킷 보드 등이 존재하는 등 내부 구현이 되어 있을 것이다. 그러나 실제로 사용할 때에는 이러한 존재에 대해서는 생각하지 않고 단순히 수화기를 들고 버튼을 눌러서 해결하는 것으로 인터페이스(interface)를 단순화할 수 있다.
- **추상화를 통해 인터페이스가 단순해진다.**
    
    너무 많은 기능들이 노출되지 않은 덕분에 예기치 못한 사용상의 변화가 일어나지 않도록 만들 수 있다.
    

> 🤔 **캡슐화 vs 추상화?**
> 
> - 캡슐화가 코드나 **데이터의 은닉**에 포커스가 맞춰져있다면, 추상화는 클래스를 사용하는 사람이 필요하지 않은 메서드 등을 노출시키지 않고, **단순한 이름으로 정의하는 것**에 포커즈가 맞춰져 있다.
> - 클래스 정의 시, 메서드와 속성만 정의한 것을 인터페이스라고 부른다. 이것이 추상화의 본질이다.


### 🧩 3. 상속 Inheritance

상속은 부모 클래스의 특징을 자식 클래스가 물려받는 것이다.

- 부모/자식으로 이야기하기도 하지만, 보다 그 특징을 자세하게 설명하는 용어는  **"기본 클래스(base class)의 특징을 파생 클래스(derived class)가 상속받는다"** 로 표현하는 것이 적합하다. (그러나, 부모/자식이라는 용어가 더욱 많이 쓰이고 있다.)
    

### 🧩 4. 다형성 Polymorphism

다형성은 특정 기능을 선언(설계)부분과 구현(동작)부분으로 분리한 후 구현부분을 다양한 방법으로 만들어 선택하여 사용할 수 있게 하는 기능이다.

- 객체 역시 “똑같은 메서드라 하더라도, 다른 방식으로 구현”될 수 있다.
- Circle, Square, Triangle 클래스가 있다고 하자. 만약 다양한 도형을 그리고 싶다고 한다면, 각 클래스에서 동그라미 그리는 메서드, 네모 그리는 메서드, 삼각형 그리는 메서드를 따로 만들어줘야할까? 아니다. 이 경우 세 클레스의 공통의 부모 클래스에 draw()라는 메서드를 선언해 놓고, 해당 기능을 쓰는 Circle, Square, Triangle 클래스에서 상속을 받아 자기 클래스에 맞게 기능을 구현해주면 된다. 이렇게 하면 같은 이름을 가진 메서드라도 조금씩 다르게 작동한다.
- 만약 다형성을 제공하지 않는다면 부모(기본) 클래스에 종류별류 if 분기문을 만들어 처리하거나, 자식(파생) 클래스가 각각 자기만의 메소드를 넣어줘야 했을 것이다. 하지만 클래스의 본질상 ‘그림을 그린다'(draw)라는 개념은 부모가 갖고 있는 것이 합리적이다.
